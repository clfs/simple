//go:build ignore

// tablegen generates lookup tables.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"

	"github.com/clfs/simple/core"
)

var output = flag.String("output", "tables.go", "file name to write")

const header = `
package movegen

import "github.com/clfs/simple/core"
`

func main() {
	log.SetFlags(0)
	log.SetPrefix("tablegen: ")
	flag.Parse()
	if flag.NArg() != 0 {
		log.Fatal("usage: tablegen [--output filename]")
	}

	var b bytes.Buffer
	fmt.Fprintf(&b, "// Code generated by go run tablegen.go -output %s; DO NOT EDIT.\n\n", *output)
	fmt.Fprint(&b, header)

	fmt.Fprintf(&b, "var whitePawnPushes = %#v\n", whitePawnPushes())
	fmt.Fprintf(&b, "var blackPawnPushes = %#v\n", blackPawnPushes())
	fmt.Fprintf(&b, "var whitePawnAttacks = %#v\n", whitePawnAttacks())
	fmt.Fprintf(&b, "var blackPawnAttacks = %#v\n", blackPawnAttacks())
	fmt.Fprintf(&b, "var knightAttacks = %#v\n", knightAttacks())
	fmt.Fprintf(&b, "var kingAttacks = %#v\n", kingAttacks())

	source, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal("source format error:", err)
	}
	fd, err := os.Create(*output)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := fd.Write(source); err != nil {
		log.Fatal(err)
	}
}

func whitePawnPushes() (table [64]core.Bitboard) {
	for s := core.A2; s <= core.H7; s++ {
		table[s].Set(s.Above())
		if s.Rank() == core.Rank2 {
			table[s].Set(s.Above().Above())
		}
	}
	return
}

func blackPawnPushes() (table [64]core.Bitboard) {
	for s := core.A2; s <= core.H7; s++ {
		table[s].Set(s.Below())
		if s.Rank() == core.Rank7 {
			table[s].Set(s.Below().Below())
		}
	}
	return
}

func whitePawnAttacks() (table [64]core.Bitboard) {
	for s := core.A2; s <= core.H7; s++ {
		if s.File() != core.FileA {
			table[s].Set(s.Above().Left())
		}
		if s.File() != core.FileH {
			table[s].Set(s.Above().Right())
		}
	}
	return
}

func blackPawnAttacks() (table [64]core.Bitboard) {
	for s := core.A2; s <= core.H7; s++ {
		if s.File() != core.FileA {
			table[s].Set(s.Below().Left())
		}
		if s.File() != core.FileH {
			table[s].Set(s.Below().Right())
		}
	}
	return
}

// delta represents a square translation.
type delta struct {
	f core.File
	r core.Rank
}

func knightAttacks() (table [64]core.Bitboard) {
	deltas := []delta{{2, 1}, {1, 2}, {-2, 1}, {-1, 2}, {2, -1}, {1, -2}, {-2, -1}, {-1, -2}}
	for s := core.A1; s <= core.H8; s++ {
		for _, d := range deltas {
			f, r := s.File()+d.f, s.Rank()+d.r
			if f.Valid() && r.Valid() {
				table[s].Set(core.NewSquare(f, r))
			}
		}
	}
	return
}

func kingAttacks() (table [64]core.Bitboard) {
	deltas := []delta{{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}}
	for s := core.A1; s <= core.H8; s++ {
		for _, d := range deltas {
			f, r := s.File()+d.f, s.Rank()+d.r
			if f.Valid() && r.Valid() {
				table[s].Set(core.NewSquare(f, r))
			}
		}
	}
	return
}
