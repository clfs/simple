//go:build ignore

// tablegen generates lookup tables.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"

	"github.com/clfs/simple/core"
)

var output = flag.String("output", "tables.go", "file name to write")

const header = `
package movegen

import "github.com/clfs/simple/core"
`

func main() {
	log.SetFlags(0)
	log.SetPrefix("tablegen: ")
	flag.Parse()
	if flag.NArg() != 0 {
		log.Fatal("usage: tablegen [--output filename]")
	}

	var b bytes.Buffer
	fmt.Fprintf(&b, "// Code generated by go run tablegen.go -output %s; DO NOT EDIT.\n\n", *output)
	fmt.Fprint(&b, header)

	writeTable(&b, "whitePawnPushes", whitePawnPushes())
	writeTable(&b, "blackPawnPushes", blackPawnPushes())
	writeTable(&b, "whitePawnAttacks", whitePawnAttacks())
	writeTable(&b, "blackPawnAttacks", blackPawnAttacks())
	writeTable(&b, "knightAttacks", knightAttacks())
	writeTable(&b, "kingAttacks", kingAttacks())

	source, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal("source format error:", err)
	}
	fd, err := os.Create(*output)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := fd.Write(source); err != nil {
		log.Fatal(err)
	}
}

// writeTable writes table to w as a Go array.
func writeTable(w io.Writer, name string, table []core.Bitboard) {
	fmt.Fprintf(w, "var %s = [%d]core.Bitboard{\n", name, len(table))
	for i := range table {
		fmt.Fprintf(w, "%#016x,", table[i])
		if i%8 == 7 {
			fmt.Fprint(w, "\n")
		}
	}
	fmt.Fprint(w, "}\n\n")
}

func whitePawnPushes() []core.Bitboard {
	var table [64]core.Bitboard
	for s := core.A2; s <= core.H7; s++ {
		table[s].Set(s.Above())
		if s.Rank() == core.Rank2 {
			table[s].Set(s.Above().Above())
		}
	}
	return table[:]
}

func blackPawnPushes() []core.Bitboard {
	var table [64]core.Bitboard
	for s := core.A2; s <= core.H7; s++ {
		table[s].Set(s.Below())
		if s.Rank() == core.Rank7 {
			table[s].Set(s.Below().Below())
		}
	}
	return table[:]
}

func whitePawnAttacks() []core.Bitboard {
	var table [64]core.Bitboard
	for s := core.A2; s <= core.H7; s++ {
		if s.File() != core.FileA {
			table[s].Set(s.Above().Left())
		}
		if s.File() != core.FileH {
			table[s].Set(s.Above().Right())
		}
	}
	return table[:]
}

func blackPawnAttacks() []core.Bitboard {
	var table [64]core.Bitboard
	for s := core.A2; s <= core.H7; s++ {
		if s.File() != core.FileA {
			table[s].Set(s.Below().Left())
		}
		if s.File() != core.FileH {
			table[s].Set(s.Below().Right())
		}
	}
	return table[:]
}

// delta represents a square translation.
type delta struct {
	f core.File
	r core.Rank
}

func knightAttacks() []core.Bitboard {
	var table [64]core.Bitboard
	deltas := []delta{{2, 1}, {1, 2}, {-2, 1}, {-1, 2}, {2, -1}, {1, -2}, {-2, -1}, {-1, -2}}
	for s := core.A1; s <= core.H8; s++ {
		for _, d := range deltas {
			f, r := s.File()+d.f, s.Rank()+d.r
			if f.Valid() && r.Valid() {
				table[s].Set(core.NewSquare(f, r))
			}
		}
	}
	return table[:]
}

func kingAttacks() []core.Bitboard {
	var table [64]core.Bitboard
	deltas := []delta{{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}}
	for s := core.A1; s <= core.H8; s++ {
		for _, d := range deltas {
			f, r := s.File()+d.f, s.Rank()+d.r
			if f.Valid() && r.Valid() {
				table[s].Set(core.NewSquare(f, r))
			}
		}
	}
	return table[:]
}
