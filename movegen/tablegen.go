//go:build ignore

// tablegen generates lookup tables.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"

	"github.com/clfs/simple/core"
)

var output = flag.String("output", "tables.go", "file name to write")

const header = `
package movegen

import "github.com/clfs/simple/core"
`

func main() {
	log.SetFlags(0)
	log.SetPrefix("tablegen: ")
	flag.Parse()
	if flag.NArg() != 0 {
		log.Fatal("usage: tablegen [--output filename]")
	}

	var b bytes.Buffer
	fmt.Fprintf(&b, "// Code generated by go run tablegen.go -output %s; DO NOT EDIT.\n\n", *output)
	fmt.Fprint(&b, header)

	fmt.Fprintf(&b, "var whitePawnPushes = %#v\n", whitePawnPushes())
	fmt.Fprintf(&b, "var blackPawnPushes = %#v\n", blackPawnPushes())
	fmt.Fprintf(&b, "var whitePawnAttacks = %#v\n", whitePawnAttacks())
	fmt.Fprintf(&b, "var blackPawnAttacks = %#v\n", blackPawnAttacks())
	fmt.Fprintf(&b, "var knightAttacks = %#v\n", knightAttacks())
	fmt.Fprintf(&b, "var kingAttacks = %#v\n", kingAttacks())

	source, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal("source format error:", err)
	}
	fd, err := os.Create(*output)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := fd.Write(source); err != nil {
		log.Fatal(err)
	}
}

func whitePawnPushes() [64]core.Bitboard {
	var t [64]core.Bitboard
	for s := core.A2; s <= core.H7; s++ {
		t[s].Set(s.Above())
		if s.Rank() == core.Rank2 {
			t[s].Set(s.Above().Above())
		}
	}
	return t
}

func blackPawnPushes() [64]core.Bitboard {
	var t [64]core.Bitboard
	for s := core.A2; s <= core.H7; s++ {
		t[s].Set(s.Below())
		if s.Rank() == core.Rank7 {
			t[s].Set(s.Below().Below())
		}
	}
	return t
}

func whitePawnAttacks() [64]core.Bitboard {
	var t [64]core.Bitboard
	for s := core.A2; s <= core.H7; s++ {
		f := s.File()
		if f != core.FileA {
			t[s].Set(s.Above().Left())
		}
		if f != core.FileH {
			t[s].Set(s.Above().Right())
		}
	}
	return t
}

func blackPawnAttacks() [64]core.Bitboard {
	var t [64]core.Bitboard
	for s := core.A2; s <= core.H7; s++ {
		f := s.File()
		if f != core.FileA {
			t[s].Set(s.Below().Left())
		}
		if f != core.FileH {
			t[s].Set(s.Below().Right())
		}
	}
	return t
}

// delta represents a square translation.
type delta struct {
	f int
	r int
}

func knightAttacks() [64]core.Bitboard {
	var t [64]core.Bitboard
	deltas := []delta{{2, 1}, {2, -1}, {1, 2}, {1, -2}, {-1, 2}, {-1, -2}, {-2, 1}, {-2, -1}}
	for s := core.A1; s <= core.H8; s++ {
		for _, d := range deltas {
			f, r := s.File()+core.File(d.f), s.Rank()+core.Rank(d.r)
			if f.Valid() && r.Valid() {
				t[s].Set(core.NewSquare(f, r))
			}
		}
	}
	return t
}

func kingAttacks() [64]core.Bitboard {
	var t [64]core.Bitboard
	deltas := []delta{{1, 1}, {1, 0}, {1, -1}, {0, 1}, {0, -1}, {-1, 1}, {-1, 0}, {-1, -1}}
	for s := core.A1; s <= core.H8; s++ {
		for _, d := range deltas {
			f, r := s.File()+core.File(d.f), s.Rank()+core.Rank(d.r)
			if f.Valid() && r.Valid() {
				t[s].Set(core.NewSquare(f, r))
			}
		}
	}
	return t
}
